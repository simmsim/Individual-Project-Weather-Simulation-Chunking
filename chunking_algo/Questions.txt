Questions

*The chunking logic is done under the assumption that the size of chunk in j direction will always be equal to the core simulation j dimension, 
since we want to include both sides for circular boundary condition. Is that ok?
    
*How should I construct data to test with? Also, how do I know how many time iteration to run? 
Do I run until convergence is reached or is it arbitrary (user specifies the number of iterations)?
    
    
* To know that my API is performing chunking/processing correctly, I'll need to compare the results with the original SOR version. Is that correct?
I guess that's not entirely correct since I've simplified the kernel. So I guess I'll have to do some checks by hand?

* In the original kernel code, the indexes are calculated from global_id and ranges. Do I have to determine the indexes the same way? Or can I just
provide EnqueueNDKernel with global id dimensions and offset (for calculating core) and then get i, j, k from get_global_id(0), ..(1) .. (2) ?

* Didn't implement using float2 (twinned buffer) - wasn't sure how std::copy would work with that? 

* Do we need to worry about chunking in k direction? Probably not..? Since we're only varying chunk size in i direction?


























ETC
kernel code uses slots for offsets

SOR stencils are weighted but can remove that weighting bit/arrays to simplify the process